Даны два файла data.csv и verify.csv. Разделитель – ';'
Поля: ID – уникальный айди записи, feature_1 … feature_124 – признаки.
В файле data.csv также присутствует target, принимающий два значения – 0 или 1

    1. Задание

        1.1. Решите задачу двухклассовой классификации, обучив модель на данных в data.csv После обучения вы должны получить вероятность принадлежности каждого объекта к таргет, равному единице 1.
        1.2. Сгруппируйте выборку по значениям вероятности с шагом 0.1, и в каждой группе посчитайте: сколько объектов в группе, сколько в группе объектов с target = 1.
Например так:
	
        1.3. Посчитайте метрики модели (F-мера, ROC-AUC, коэффициент Джини и другие) на данных из data.csv

Основная метрика для задания – ROC-AUC.

        1.4. С помощью полученной модели определите вероятность принадлежности к таргет 1 каждого объекта из verify.csv. 
        1.5. Запишите полученные предсказания в csv-файл (разделитель – точка с запятой). В файле должны быть два поля: ID – айди который задан в файле verify.csv и score – вероятность которую вы получили для данного ID.

Пример файла:



Таким образом, по результатам задания вы должны получить:
    • метрики модели на данных из data.csv
    • таблицу с группировкой
    • файл с предсказаниями на данных из файла verify.csv 
    • записки/текстовые файлы с кратким описанием хода обучения
Необходимо использовать логистическую регрессию. Если есть желание, дополнительно можете прислать результаты любой другой модели, если считаете, что она лучше.
    2. Вопросы
Ответьте на следующие вопросы:
    • Как можно заполнить пропущенные значения в данных?
    • Что делать, если таргет несбалансированный?
    • Как бороться с переобучением?
    • Найдите потенциальные причины аномалий в наборе данных.
    • Что делать, если данных не хватает или они плохого качества?
    • Что можно сделать чтобы повысить качество?


Вопросы по SQL
    1) За что отвечает символ звёздочка (*) в SQL-запросе select?

    2) Чем отличается оператор union от оператора join?


    3) Чем отличается union от union all?

    4) Расставьте в хронологическом порядке операции над БД выполняемые в следующем запросе, написав номер операции над ней в таблице ниже::

select top 10 *
from weather w (nolock) left join holidays h (nolock)
	on w.date = h.date and h.event != 'Christmas_holidays'
where h.type = 'Weekend'
group by month(w.date)
having datepart(year, h.date) % 4 = 0
order by h.weekday
6
1
2
3
4
5
7

select top 10 *
from weather w (nolock)
where h.type = 'Weekend'




    5) Если имеются две таблицы с совпадающими названиями полей (например таблицы Weather с полем date и таблица Holidays с полем date), объединенный join-ом по некоторому полю != date ,  а нужно вывести результат только одной таблицы. Каким образом это указывается в запросе?

    6) Какая конструкция будет (в среднем) выполняться быстрее:
select
	Клиент,
	case when Источник_клиента = 'интернет-заявка'
		then '1'
		when Источник_клиента = 'оффлайн'
		then '2'
	end "Категория клиента"
from Clients (nolock)
--=======================
select
	Клиент,
	1 as Категория клиента
from Clients (nolock)
where Источник_клиента = 'интернет-заявка'

union all
	
select
	Клиент,
	2 as Категория клиента
from Clients (nolock)
where Источник_клиента = 'оффлайн'

    7) Имеются 2 поля  в формате datetime, но из-за неудачного проектирования запись идет таким образом, что в одном поле дата, но без времени, а в другом поле – время, но без даты, нужно получить одно поле в котором будет и дата и время:

date (datetime, но  время не пишется – оно всегда статично)
Time (пишется время, но день всегда статичен)
Нужное поле – содержит и время, и дату
2020-01-14 00:00:00:000
1970-01-01 01:38:00:000
2020-01-14  01:38:00:0000
2020-01-15 00:00:00:000
1970-01-01 12:56:00:000
2020-01-15  12:56:00:0000
2020-01-16 00:00:00:000
1970-01-01 11:58:04:000
2020-01-16 11:58:04:0000
2020-01-17 00:00:00:000
1970-01-01 08:38:07:000
2020-01-17  08:38:07:0000


    8) Что является более быстрым при прочих равных  при select-запросе из двух объединенных таблиц – указание условий в блоке join или указание условий в блоке where?

    9) Чем отличается raw_number от rank? 


    10) Какой командой можно вернуть все строки таблице, где поле Comment содержит хотя бы пробел или пустое выражение (но не NULL):
Пример таблицы
Id
Comment
1
NULL
2
_
3
Ada___
4
Не известноыыю
5
Кто здесь??


    11) Напишите условие, которое вернет все строки, содержащие нижнее подчеркивание в поле Comment
    12) Перед вами таблица и запрос, формирующий, поле «Сумма» , которое  должно содержать сумму значений полей «Проценты»  и «Основной долг». При этом поля «Проценты»  и «Основной долг» не заполнялись  значениями, если оплат не поступало. Какая была допущена ошибка при формировании поля Сумма, на ваш взгляд и как её исправить?

Select «Проценты»  +  «Основной долг» as «Сумма» from Tab

Проценты
Основной долг
Сумма
10
8 000
8 010
12
9 000
9 012
NULL
11 000
NULL
NULL
80 000
NULL

    13) Напишите запрос, возвращающий последнее действие клиента в хронологическом порядке  на веб-странице в виде таблицы «Клиент такой-то» - «Переход на вкладку Займы»

Tab
Client
Date_time
Action
312
2020-01-01 14:22:01
Авторизация
312
2020-01-01 14:24:01
Переход на вкладку Займы
312
2020-01-01 14:25:01
Переход на вкладку Займы
312
2020-01-01 14:28:01
Досрочное гашение тела
312
2020-01-01 14:29:01
Выход из личного кабинета
5967
2020-01-01 14:10:01
Авторизация
5967
2020-01-01 14:12:01
Переход на вкладку Займы
5967
2020-01-01 14:15:01
Досрочное гашение тела
899
2020-01-01 14:40:01
Авторизация

    14) Имеется таблица
Tab
ID_CLIENT
ID_DOGOVOR
Interest_rate (Процентная ставка по договору)
1
1
1
2
2
1.2
1
3
1.2
1
4
1.5
2
5
2
3
6
2

Напишите запрос, который выведет список клиентов (без повторений), у которых процентная ставка больше 1.3% 

    15) Напишите запрос, подсчитывающий по таблице из предыдущего задания, сколько у каждого из клиентов договоров

    16) Имеются две таблицы: Dogovor (список договоров клиентов, уникальный ключ ID – номер договора)  и Clients (содержит персональные данные клиента, уникальный ключ – ID- идентификатор клиента):

Dogovor
ID
ID_CLIENT
Interest_rate (Процентная ставка по договору)
1
1
1
2
2
1.2
3
1
1.2
4
1
1.5
5
2
2
6
3
2


Clients
ID
Second_name (фамилия)
Age (возраст)
1
Иванов
23
2
Кукина
42
3
Костицин
30

Напишите запрос, который вернет номера  договоров тех клиентов, которым больше 25 лет

    17) Имеются две таблицы, смысл таблиц не имеет  значения
Tab1
Document_number
Date
Expiration_days
1
2019-01-01
7
2
2019-01-01
8
3
2020-03-03
9

Tab2
Document_number
Date
1
2019-01-01
2
2019-01-01

Имеется запрос по left join таблицы Tab2 к таблице Tab1 по полю Date (есть в обеих таблицах), благодаря которому возвращаются столбцы обеих таблиц (все):
Запрос написан в виде:
Select
	Tab1.Date
	,Tab1.Document_number as “Первый документ”
	,Tab2.Document_number as “Второй документ”
From
	Tab1
	Left join
	Tab2
	On Tab1.Date = Tab2.Date
Подумайте, сколько строк будет в результате его выполнения:
2
4 
5
6
Нарисуйте таблицу с результатом

Будут ли пустые значения (NULL) хоть в каком-нибудь поле?

Сколько будет строк, если left join заменить на inner join 
2
3
4
5
    18) Имеется таблица по клиентам и договорам, заключенным с ними, напишите команду (часть запроса), которая бы проставляла порядковый номер договора по каждому клиенту

Пример таблицы и поля, в котором проставляется порядковый номер договора по клиенту
ID_CLIENT
ID_DOGOVOR
Порядковый номер договора клиента
1
1
1
2
2
1
1
3
2
1
4
3
2
5
2
3
6
1


    19) Напишите конструцию (часть запроса), которая считает число дней просрочки клиента по следующей таблице (а если клиент погасил ранее, чем дата по договору, должен проставляться нолик – нет просрочки)
Договор
Fact_expiration (фактическая дата закрытия договора)
Plan_expiration (Планируемая дата закрытия договора)
Формируемое поле по числу дней просрочки
1
2018-07-11
2018-08-10
0
2
2019-02-15
2019-01-25
20
3
2019-07-15
2019-07-14
1


    20) Имеется таблица по списку договоров клиентов, в ней есть поле D_DATEINPUT с датой заключения договора в формате “2019-05-01 18:12:15” типа datetime

Напишите команду для отделения от даты месяца (в каком виде будет возвращаться месяц – May или «05» или «5» - не имеет значения)



    21) Преобразуйте запись в формате строки ’30-01-2020’ в дату

    22) Какие существуют функции, позволяющиеся представить запись формата datetime (например, 20181031 00:00:00:012) 
    • в строку нужного вида (например ’31 октября 2018’) 

    • в запись того же формата datetime, но в нужном виде (например 31.10.18) 

    23) За что отвечает команда GO в SQL?

    24) С помощью какой команды можно завести переменную?

    25) Какие бывают типы данных в SQL?


    26) Соотнесите команды SQL с их смысловой нагрузкой:
Drop (if exists)

Изменить типы данных полей или добавить новые столбцы
Update

Удалить таблицу из базы данных (полностью, как объект, а не просто стереть))
Insert

Создать пустую таблицу, дать наименования полям и назначить типы данных для полей
Select  … into… from …

Добавить записи к уже существующей таблице
Create table …

Изменить строки в таблицы в соответствии с некоторым условием
Alter table … add…

Добавить столбцы к существующей таблицу
Alter table … alter column …

Очистить таблицу, но не удалять её
Truncate …

Создать новую таблицу с одновременным помещением туда записей

    27) Как сделать так, чтобы команды в SQL-скрипте выполнялись пошагово, а не одновременно? (например при создании таблицы, добавлении полей и изменения их типов)

    28) Вернет ли ошибку нижеприведенный запрос или отработает без ошибок:
declare @name varchar = 'Nikolay'
select * from Clients_offline where Name = @name
GO
select * from Clients_online where Name = @name 

